package file::Chunk::Bcp;
################################################################################
#
#				Required Modules
#
################################################################################

use strict;

use Pod::Usage;

use util::Constants;

use file::ErrMsgs;

use base 'file::Chunk';

use fields qw (
  chunk_field_separator
  entities
  entity
  field_separator
  ord
);

################################################################################
#
#				   Constants
#
################################################################################
###
### File Type
###
sub FILE_TYPE { return 'bcp'; }
###
### Buffer Size
###
sub LOCAL_BATCH_SIZE { return 100000; }
###
### Error Category
###
sub ERR_CAT { return file::ErrMsgs::CHUNK_CAT; }

################################################################################
#
#			     Private Methods
#
################################################################################

sub _readBcpEntity {
  my file::Chunk::Bcp $this = shift;
  my $found_entity          = util::Constants::FALSE;
  my $bcp_line              = undef;
  while ( !$this->{source_fh}->eof ) {
    my $line = $this->{source_fh}->getline;
    if    ( $/ eq util::Constants::CTRLM )   { $line =~ s/\n//g; }
    elsif ( $/ eq util::Constants::NEWLINE ) { $line =~ s///g; }
    chomp($line);
    next
      if ( !defined($line)
      || $line eq util::Constants::EMPTY_STR
      || $line =~ /^\s+$/
      || $line =~ /^#/ );
    $found_entity = util::Constants::TRUE;
    $bcp_line     = $line;
    last;
  }
  if ($found_entity) {
    $this->{entity} = {};
    foreach my $col ( @{ $this->{ord} } ) { $this->{entity}->{$col} = undef; }
    my $field_separator = $this->{field_separator};
    my @row = split( /$field_separator/, $bcp_line );
    foreach my $index ( 0 .. $#row ) {
      my $col = $row[$index];
      next
        if ( !defined($col)
        || $col eq util::Constants::EMPTY_STR
        || $col =~ /^ +$/ );
      $this->{entity}->{ $this->{ord}->[$index] } = $col;
    }
  }
  return $found_entity;
}

sub _getLine {
  my file::Chunk::Bcp $this = shift;
  my @cols = ();
  foreach my $col ( @{ $this->{ord} } ) {
    push( @cols, $this->{entity}->{$col} );
  }
  return join( $this->{chunk_field_separator}, @cols );
}

################################################################################
#
#				 Public Methods
#
################################################################################

sub new {
  my ( $that, $directory, $file_ord, $field_separator, $record_separator,
    $error_mgr )
    = @_;

  my file::Chunk::Bcp $this =
    $that->SUPER::new( FILE_TYPE, LOCAL_BATCH_SIZE, $directory, $error_mgr );

  $this->{field_separator} = $field_separator;

  $this->{chunk_field_separator} = $field_separator;
  my $tab     = util::Constants::TAB;
  my $newline = util::Constants::NEWLINE;
  $this->{chunk_field_separator} =~ s/\\t/$tab/g;
  $this->{chunk_field_separator} =~ s/\\n/$newline/g;
  $this->{chunk_field_separator} =~ s/\\//g;
  $this->{chunk_field_separator} =~ s/\+//g;

  $this->{ord} = $file_ord;
  $this->{error_mgr}->exitProgram( ERR_CAT, 9, [ ref($this) ],
        !defined( $this->{ord} )
      || ref( $this->{ord} ) ne 'ARRAY'
      || @{ $this->{ord} } == 0 );

  $this->setLineSeparator($record_separator);

  return $this;
}

sub chunkFile {
  my file::Chunk::Bcp $this = shift;
  $this->{file_index} = {};
  $this->{files}      = [];
  $this->{lines}      = [];
  my $entity_count = 0;
  while ( $this->_readBcpEntity ) {
    $entity_count++;
    push( @{ $this->{lines} }, $this->_getLine );
    $this->writeChunk if ( $entity_count % $this->{size} == 0 );
  }
  $this->writeChunk;
  $this->closeSourceFile;
  return scalar @{ $this->{files} };
}

sub readBcpFile {
  my file::Chunk::Bcp $this = shift;
  $this->{entities} = [];
  while ( $this->_readBcpEntity ) {
    push( @{ $this->{entities} }, $this->{entity} );
  }
  $this->closeSourceFile;
}

sub getEntities {
  my file::Chunk::Bcp $this = shift;
  return $this->{entities};
}

################################################################################

1;

__END__

=head1 NAME

Bcp.pm

=head1 SYNOPSIS

This concrete class provides the mechanism to chunk a bcp formated
file into smaller chunks for processing and is subclass of
L<file::Chunk>.  Each line is an entity if it is not empty, just
whitespace, or starts with a pound character (B<#>).  The file order
names the columns of the bcp formated line and is used to define the
entities generated by the class.

=head1 METHODS

The following methods are exported from the class.

=head2 B<new file::Chunk::Bcp(directory, file_order, field_separator, record_separator, error_mgr)>

This is the constructor of the class and requires the file_order
(referenced) array that defines the names of the columns in the
bcp-file using the given field and record separators.  Also, the
directory is where the chunks will be generated.  The constructor set
the size to 5000 defined rows.  The construct sets the file order
using the reference non-empty array B<file_order>.

=head2 B<chunkFile>

This method takes the stream represented by the file handle, fh and
chunks it size entities where entity boundaries are not violated.
Each chunk will be generated into a gzipped filename, where N is the
chunk number (N >= 0) and B<directory> and B<chunk_prefix> are the
attributes of the object:

  <directory>/<chunk_prefix>.000N.bcp.gz,         N < 10
  <directory>/<chunk_prefix>.00N.bcp.gz,  10   <= N < 100
  <directory>/<chunk_prefix>.0N.bcp.gz,   100  <= N < 1000
  <directory>/<chunk_prefix>.N.bcp.gz,    1000 <= N < 10000

This method returns the number of chunks created.

=head2 B<readBcpFile>

This method reads the source_file into the entities array which is a
list of hash entries with the keys defined by the file order.

=head2 B<$entities = getEntities>

This method returns the array of entities generated by
L<"readBcpFile">.

=cut
